================================================================================
REQUIREMENT 6 - КРАТКОЕ ОПИСАНИЕ ИЗМЕНЕНИЙ
================================================================================
Дата: 2025-11-07
Задача: Полиморфизм через Price Policies + Перегрузка/Переопределение методов

================================================================================
1. НОВЫЕ ФАЙЛЫ (5 штук)
================================================================================

src/product/pricing/PricePolicy.java
    Интерфейс для ценовых политик
    Методы:
      - String name() - название политики
      - double apply(Product p, int qty) - расчет цены (НЕ мутирует товар!)
      - default boolean applicableTo(Product p) - применима ли политика

src/product/pricing/PercentageOff.java
    Процентная скидка (0-90%)
    Пример: PercentageOff(10) дает -10% от цены
    Расчет: price * (1 - percent/100) * qty

src/product/pricing/FixedOff.java
    Фиксированная скидка в тенге с каждого товара
    Пример: FixedOff(50) вычитает 50 KZT с каждой единицы
    Расчет: max(0, price - amount) * qty

src/product/pricing/BogoHalf.java
    "Купи одну - вторую за полцены"
    Расчет: pairs * (price * 1.5) + singles * price
    Где pairs = qty/2, singles = qty%2
    ВАЖНО: Применяется только к физическим товарам!

src/product/ShopDemo5.java
    Демонстрация полиморфизма:
    - Создает List<Product> с Physical и Digital товарами
    - Создает List<PricePolicy> с тремя политиками
    - Для каждого товара вычисляет цену со всеми политиками
    - Показывает лучшую (минимальную) цену

================================================================================
2. ИЗМЕНЕНИЯ В Product.java
================================================================================

Место: После метода calculateTotalValue() (строка ~158)

ДОБАВЛЕНО 4 перегруженных метода finalPrice():

1) finalPrice()
   - Возвращает цену за 1 единицу без скидок
   - return getPrice();

2) finalPrice(int qty)
   - Возвращает цену за qty единиц без скидок
   - return getPrice() * qty;
   - Защита: если qty <= 0, возвращает 0.0

3) finalPrice(int qty, PricePolicy policy)
   - Возвращает цену за qty единиц С УЧЕТОМ политики
   - Если policy == null или не применима → базовая цена
   - Иначе → policy.apply(this, qty)

4) finalPrice(int qty, List<PricePolicy> policies)
   - Возвращает МИНИМАЛЬНУЮ цену среди всех политик
   - Перебирает все политики, вызывает finalPrice(qty, pp) для каждой
   - Возвращает лучшую для покупателя

ЧТО ДЕМОНСТРИРУЕТСЯ:
- Method Overloading (перегрузка) - compile-time polymorphism
- Компилятор выбирает метод по сигнатуре (кол-во и типы параметров)

================================================================================
3. ИЗМЕНЕНИЯ В PhysicalProduct.java
================================================================================

Место: После метода getHeightCm() (строка ~76)

ДОБАВЛЕНО 2 переопределенных метода:

@Override finalPrice(int qty, PricePolicy policy)
    double base = super.finalPrice(qty, policy);
    return base + estimateShippingCost();

    СУТЬ: Вызывает родительский метод (цена + скидка),
          затем добавляет доставку

@Override finalPrice(int qty, List<PricePolicy> policies)
    double base = super.finalPrice(qty, policies);
    return base + estimateShippingCost();

    СУТЬ: Находит лучшую цену, затем добавляет доставку

ВАЖНО: Доставка добавляется ОДИН РАЗ на заказ, не на каждый товар!

ЧТО ДЕМОНСТРИРУЕТСЯ:
- Method Overriding (переопределение) - runtime polymorphism
- PhysicalProduct имеет специфичное поведение (добавляет доставку)

================================================================================
4. ИЗМЕНЕНИЯ В DigitalProduct.java
================================================================================

Место: После метода getLicenseKey() (строка ~58)

ДОБАВЛЕНО 1 переопределенный метод:

@Override finalPrice(int qty, PricePolicy policy)
    if (policy instanceof product.pricing.BogoHalf) {
        return super.finalPrice(qty); // игнорируем BOGO
    }
    return super.finalPrice(qty, policy);

    СУТЬ: Если политика = BogoHalf, игнорирует ее (возвращает базовую цену)
          Для остальных политик работает как обычно

ОБОСНОВАНИЕ:
Акция "вторую за полцены" не имеет смысла для цифровых товаров
(нет себестоимости копирования)

ЧТО ДЕМОНСТРИРУЕТСЯ:
- Method Overriding - runtime polymorphism
- Type-specific behavior через instanceof

================================================================================
5. КЛЮЧЕВЫЕ КОНЦЕПЦИИ ПОЛИМОРФИЗМА
================================================================================

1. COMPILE-TIME POLYMORPHISM (Перегрузка методов)
   - 4 метода finalPrice() с разными сигнатурами
   - Компилятор выбирает метод на этапе компиляции
   - Зависит от типов и количества параметров

2. RUNTIME POLYMORPHISM (Переопределение методов)
   - PhysicalProduct.finalPrice() добавляет доставку
   - DigitalProduct.finalPrice() игнорирует BogoHalf
   - JVM выбирает метод на этапе выполнения по фактическому типу объекта

3. INTERFACE-BASED POLYMORPHISM (Интерфейсы)
   - PricePolicy - единый интерфейс
   - 3 разные реализации (PercentageOff, FixedOff, BogoHalf)
   - Product работает с интерфейсом, не зная конкретной реализации
   - Легко добавлять новые политики без изменения Product

4. SUBTYPE POLYMORPHISM (Наследование)
   - List<Product> содержит Physical и Digital товары
   - Единый интерфейс, разное поведение
   - Принцип Liskov Substitution (SOLID)

================================================================================
6. СРАВНЕНИЕ: СТАРЫЙ vs НОВЫЙ ПОДХОД
================================================================================

СТАРЫЙ: applyDiscount(double percent)
  × Мутирует товар (изменяет price)
  × Один тип скидки (только процентная)
  × Нельзя сравнить варианты
  × Нельзя отменить скидку

НОВЫЙ: finalPrice(...) + PricePolicy
  ✓ НЕ мутирует товар (immutable подход)
  ✓ Множество типов политик (расширяемо)
  ✓ Можно сравнить все варианты
  ✓ Можно вычислить цену многократно
  ✓ Каждый товар может по-своему реагировать на политики

================================================================================
7. РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ
================================================================================

КОМАНДЫ:
javac -d out src/category/*.java src/product/*.java src/product/pricing/*.java
java -cp out product.ShopDemo5

КЛЮЧЕВЫЕ РЕЗУЛЬТАТЫ:

Laptop (PhysicalProduct), qty=1:
  Базовая: 450,000 KZT
  Percent-10%: 405,180 KZT (скидка + доставка 180 KZT)
  Fixed-50: 450,130 KZT
  BOGO-HALF: 450,180 KZT
  Лучшая: 405,180 KZT

Laptop (PhysicalProduct), qty=2:
  Базовая: 900,000 KZT
  Percent-10%: 810,180 KZT
  Fixed-50: 900,080 KZT
  BOGO-HALF: 675,180 KZT ← ЛУЧШАЯ! (экономия 225K)
  Лучшая: 675,180 KZT

E-Book (DigitalProduct), qty=1:
  Базовая: 1,500 KZT
  Percent-10%: 1,350 KZT ← ЛУЧШАЯ
  Fixed-50: 1,450 KZT
  BOGO-HALF: 1,500 KZT (игнорируется!)

E-Book (DigitalProduct), qty=2:
  Базовая: 3,000 KZT
  Percent-10%: 2,700 KZT ← ЛУЧШАЯ
  Fixed-50: 2,900 KZT
  BOGO-HALF: 3,000 KZT (игнорируется!)

ПОДТВЕРЖДЕНИЕ ПОЛИМОРФИЗМА:
✓ PhysicalProduct добавляет ~180 KZT доставки ко всем ценам
✓ DigitalProduct игнорирует BOGO-HALF (цена = базовая)
✓ Метод finalPrice(qty, List) корректно выбирает минимум
✓ Разные политики дают разные результаты

================================================================================
8. АРХИТЕКТУРНАЯ СХЕМА
================================================================================

        PricePolicy (interface)
             ↑
    ┌────────┼────────┐
    │        │        │
PercentageOff FixedOff BogoHalf
    │        │        │
    └────────┼────────┘
             ↓
          Product
       (4 метода finalPrice)
             ↑
    ┌────────┴────────┐
    │                 │
PhysicalProduct  DigitalProduct
(+доставка)      (-BogoHalf)

================================================================================
9. СПИСОК ВСЕХ ИЗМЕНЕНИЙ
================================================================================

СОЗДАНО:
✓ Папка src/product/pricing/
✓ PricePolicy.java (интерфейс)
✓ PercentageOff.java
✓ FixedOff.java
✓ BogoHalf.java
✓ ShopDemo5.java

ИЗМЕНЕНО:
✓ Product.java - добавлены 4 метода finalPrice()
✓ PhysicalProduct.java - переопределены 2 метода finalPrice()
✓ DigitalProduct.java - переопределен 1 метод finalPrice()

ПРОТЕСТИРОВАНО:
✓ Компиляция успешна
✓ ShopDemo5 работает корректно
✓ Полиморфизм работает как ожидается

================================================================================
ИТОГО
================================================================================

Реализованы ВСЕ требования Requirement 6:
1. Интерфейс PricePolicy + 3 реализации ✓
2. Перегрузка методов (4 сигнатуры finalPrice) ✓
3. Переопределение методов в подклассах ✓
4. Полиморфные списки в ShopDemo5 ✓
5. Демонстрация compile-time и runtime полиморфизма ✓

Ключевое отличие от прежней версии:
НЕ МУТИРУЕМ товар, ВЫЧИСЛЯЕМ финальную цену с разными политиками.
Это позволяет сравнивать варианты и легко расширять систему.
