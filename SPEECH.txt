═══════════════════════════════════════════════════════════════════
РЕЧЬ ДЛЯ ПРЕЗЕНТАЦИИ REQUIREMENT 6 (5-7 минут)
═══════════════════════════════════════════════════════════════════

1. ВВЕДЕНИЕ (1 минута)
═══════════════════════════════════════════════════════════════════

"Добрый день! Я представляю Requirement 6 - систему ценовых политик для интернет-магазина, которая демонстрирует полиморфизм в Java.

До этого у меня был базовый класс Product и два наследника - PhysicalProduct и DigitalProduct. Была одна проблема: старый метод applyDiscount() изменял цену товара навсегда - нельзя было сравнить варианты или откатить изменения.

Requirement 6 решает эту проблему и демонстрирует ТРИ типа полиморфизма:
- Interface-based polymorphism через интерфейс PricePolicy
- Compile-time polymorphism через перегрузку методов
- Runtime polymorphism через переопределение методов"


2. ПОКАЗ КОДА (3 минуты)
═══════════════════════════════════════════════════════════════════

[Открыть PricePolicy.java]

"Основа системы - интерфейс PricePolicy. Это контракт для всех ценовых политик:

- name() - название политики
- apply() - вычисляет финальную цену, НЕ изменяя товар
- applicableTo() - проверяет, применима ли политика к товару

Это Interface-based polymorphism - разные классы реализуют один интерфейс."

[Открыть BogoHalf.java]

"У меня три реализации. Самая интересная - BogoHalf, акция 'купи один, получи второй за полцены':

```
int pairs = qty / 2;          // Делим на пары
int singles = qty % 2;        // Остаток
return pairs * (price * 1.5) + singles * price;
```

Пара товаров стоит 1.5 цены вместо 2. Экономия 25%!"

[Открыть Product.java, строки 159-192]

"В Product я добавил 4 перегруженных метода finalPrice() - это Compile-time polymorphism:

- finalPrice() - цена за 1 штуку
- finalPrice(qty) - цена за qty штук
- finalPrice(qty, policy) - с одной политикой
- finalPrice(qty, list) - выбирает ЛУЧШУЮ политику из списка

Компилятор выбирает метод по количеству и типам параметров."

[Открыть PhysicalProduct.java, строки 77-94]

"PhysicalProduct переопределяет метод - это Runtime polymorphism:

```
@Override
public double finalPrice(int qty, PricePolicy policy) {
    double base = super.finalPrice(qty, policy);  // Родительский метод
    return base + estimateShippingCost();         // + доставка
}
```

Вызывает родительский метод, потом добавляет доставку ОДИН РАЗ на заказ."

[Открыть DigitalProduct.java, строки 64-70]

"DigitalProduct тоже переопределяет, но по-другому - игнорирует BogoHalf:

```
if (policy instanceof BogoHalf) {
    return super.finalPrice(qty);  // Игнорируем BOGO
}
```

Потому что акция 'второй за полцены' не имеет смысла для цифровых товаров."


3. ДЕМОНСТРАЦИЯ РАБОТЫ (2 минуты)
═══════════════════════════════════════════════════════════════════

[Открыть терминал]

"Запускаем программу:

javac -d out src/category/*.java src/product/*.java src/product/pricing/*.java
java -cp out product.ShopDemo5"

[Показать вывод]

"Смотрите на Laptop за 450,000 KZT:

При qty=1:
- Базовая: 450,000
- Скидка 10%: 405,180 - ЛУЧШАЯ
- BOGO: 450,180 (нет пары)

Видите +180 KZT ко всем ценам? Это доставка от PhysicalProduct.

При qty=2 картина меняется:
- Базовая: 900,000
- Скидка 10%: 810,180
- BOGO: 675,180 - ТЕПЕРЬ ЛУЧШАЯ!

BOGO экономит 225 тысяч! Почему? 450,000 × 1.5 = 675,000 + 180 доставка.

Теперь E-Book за 1,500 KZT:

При qty=2:
- Скидка 10%: 2,700 - лучшая
- BOGO: 3,000 - ИГНОРИРУЕТСЯ!

Видите? BOGO вернул базовую цену, потому что DigitalProduct игнорирует эту политику.

И нет доставки для цифровых товаров."


4. ВЫВОДЫ (1 минута)
═══════════════════════════════════════════════════════════════════

"Что реализовано:

✓ Интерфейс PricePolicy с тремя политиками - Interface-based polymorphism
✓ 4 перегруженных метода finalPrice() - Compile-time polymorphism
✓ Переопределение в подклассах - Runtime polymorphism

Преимущества:
- НЕ мутирует товар - можно пересчитывать сколько угодно
- Легко добавлять новые политики - один класс, остальное не трогаем
- Каждый тип товара реагирует по-своему

Это Strategy Pattern по SOLID принципам. Такая же архитектура используется в Amazon, Wildberries, Kaspi.kz.

Спасибо! Готов ответить на вопросы."


═══════════════════════════════════════════════════════════════════
ВОЗМОЖНЫЕ ВОПРОСЫ
═══════════════════════════════════════════════════════════════════

Q: Почему интерфейс, а не абстрактный класс?
A: Нет общего состояния между политиками, только контракт. Интерфейс идеален. Плюс есть default метод applicableTo().

Q: Почему apply() не изменяет цену?
A: Immutability - можем пересчитывать, сравнивать варианты, не боясь изменить исходные данные.

Q: Как выбирается лучшая политика?
A: Перебираем все, вызываем apply() для каждой, сохраняем минимум - это выгоднее для покупателя.
