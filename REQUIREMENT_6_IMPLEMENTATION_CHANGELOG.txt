================================================================================
  REQUIREMENT 6 IMPLEMENTATION - ПОЛНОЕ ОПИСАНИЕ ИЗМЕНЕНИЙ И ДОПОЛНЕНИЙ
================================================================================

Дата реализации: 2025-11-07
Задача: Реализация полиморфизма через Price Policies + Method Overloading/Overriding


================================================================================
  1. НОВАЯ СТРУКТУРА ПРОЕКТА
================================================================================

ДОБАВЛЕНА новая папка и 5 новых файлов:

    src/product/pricing/               (новая папка)
        ├── PricePolicy.java           (новый интерфейс)
        ├── PercentageOff.java         (новая политика)
        ├── FixedOff.java              (новая политика)
        ├── BogoHalf.java              (новая политика)

    src/product/
        └── ShopDemo5.java             (новый демо-класс)

ИЗМЕНЕНЫ существующие файлы:
    - Product.java                     (добавлены 4 метода finalPrice)
    - PhysicalProduct.java             (переопределены 2 метода finalPrice)
    - DigitalProduct.java              (переопределен 1 метод finalPrice)


================================================================================
  2. ИНТЕРФЕЙС PricePolicy (НОВЫЙ ФАЙЛ)
================================================================================

Файл: src/product/pricing/PricePolicy.java

НАЗНАЧЕНИЕ:
    Базовый интерфейс для всех ценовых политик (скидок/акций).
    Реализует паттерн "Strategy" для расчета финальной цены.

КЛЮЧЕВЫЕ МЕТОДЫ:
    ┌─────────────────────────────────────────────────────────────────────┐
    │ String name()                                                       │
    │   - Возвращает человекочитаемое название политики                  │
    │   - Используется для вывода информации пользователю                │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │ double apply(Product p, int qty)                                    │
    │   - Вычисляет финальную стоимость для qty единиц товара p          │
    │   - НЕ изменяет товар (immutable подход)                           │
    │   - Возвращает итоговую цену БЕЗ доставки                          │
    └─────────────────────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────────────────────┐
    │ default boolean applicableTo(Product p)                             │
    │   - Проверяет, применима ли политика к данному товару              │
    │   - По умолчанию = true (применима ко всем)                        │
    │   - Может быть переопределена для специфических политик            │
    └─────────────────────────────────────────────────────────────────────┘

ПРИНЦИП РАБОТЫ:
    Интерфейс позволяет создавать разные стратегии ценообразования,
    не меняя код товаров. Это демонстрирует ПОЛИМОРФИЗМ ИНТЕРФЕЙСОВ.


================================================================================
  3. КЛАСС PercentageOff (НОВЫЙ ФАЙЛ)
================================================================================

Файл: src/product/pricing/PercentageOff.java

НАЗНАЧЕНИЕ:
    Политика процентной скидки (например, -10%, -20%)

ПОЛЯ:
    private final double percent;  // Процент скидки, ограничен 0-90%

КОНСТРУКТОР:
    public PercentageOff(double percent)
        - Принимает процент скидки
        - Автоматически ограничивает диапазон [0, 90]
        - Защита от ошибок: Math.max(0, Math.min(90, percent))

АЛГОРИТМ РАСЧЕТА:
    1. Получить базовую цену товара: p.getPrice()
    2. Применить скидку: unit = price * (1 - percent/100)
    3. Умножить на количество: unit * qty
    4. Вернуть итоговую сумму

ПРИМЕР:
    Товар стоит 1000 KZT, скидка 10%, количество 2
    → unit = 1000 * (1 - 0.1) = 900 KZT
    → итого = 900 * 2 = 1800 KZT


================================================================================
  4. КЛАСС FixedOff (НОВЫЙ ФАЙЛ)
================================================================================

Файл: src/product/pricing/FixedOff.java

НАЗНАЧЕНИЕ:
    Политика фиксированной скидки (например, -50 KZT с каждого товара)

ПОЛЯ:
    private final double amount;  // Сумма скидки с одного товара

КОНСТРУКТОР:
    public FixedOff(double amount)
        - Принимает сумму скидки
        - Автоматически защищает от отрицательных значений: Math.max(0, amount)

АЛГОРИТМ РАСЧЕТА:
    1. Получить базовую цену товара: p.getPrice()
    2. Вычесть скидку: unit = Math.max(0.0, price - amount)
    3. Умножить на количество: unit * qty
    4. Защита: цена не может быть отрицательной

ПРИМЕР:
    Товар стоит 1500 KZT, скидка 50 KZT, количество 2
    → unit = max(0, 1500 - 50) = 1450 KZT
    → итого = 1450 * 2 = 2900 KZT


================================================================================
  5. КЛАСС BogoHalf (НОВЫЙ ФАЙЛ)
================================================================================

Файл: src/product/pricing/BogoHalf.java

НАЗНАЧЕНИЕ:
    Политика "Купи один - второй за полцены" (Buy-One-Get-One-Half)
    Применяется только к физическим товарам

АЛГОРИТМ РАСЧЕТА:
    1. Разделить количество на пары (qty / 2) и остаток (qty % 2)
    2. Каждая пара стоит: price * 1.5 (100% + 50%)
    3. Каждый одиночный товар стоит: price * 1.0
    4. Итого: pairs * (price * 1.5) + singles * price

ПРИМЕР:
    Товар стоит 1000 KZT, количество 3
    → pairs = 3 / 2 = 1 пара
    → singles = 3 % 2 = 1 товар
    → итого = 1 * (1000 * 1.5) + 1 * 1000 = 1500 + 1000 = 2500 KZT

    Сравнение с обычной ценой:
    Без акции: 3 * 1000 = 3000 KZT
    С акцией:  2500 KZT
    Экономия:  500 KZT (16.7%)

ОСОБЕННОСТЬ:
    Цифровые товары (DigitalProduct) ИГНОРИРУЮТ эту политику!


================================================================================
  6. ИЗМЕНЕНИЯ В КЛАССЕ Product
================================================================================

Файл: src/product/Product.java
Место изменений: После метода calculateTotalValue(), строка ~158

ДОБАВЛЕНО: 4 перегруженных метода finalPrice()

┌─────────────────────────────────────────────────────────────────────────────┐
│ МЕТОД 1: public double finalPrice()                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│ Параметры: нет                                                              │
│ Возвращает: Цену за 1 единицу товара без скидок                            │
│ Реализация: return getPrice();                                              │
│                                                                              │
│ Пример использования:                                                       │
│     Product p = new Product("P1", "Book", 1500);                            │
│     double price = p.finalPrice();  // 1500.0                               │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ МЕТОД 2: public double finalPrice(int qty)                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│ Параметры: int qty - количество товаров                                    │
│ Возвращает: Цену за qty товаров без скидок                                 │
│ Защита: Если qty <= 0, возвращает 0.0                                      │
│ Реализация: return getPrice() * qty;                                        │
│                                                                              │
│ Пример использования:                                                       │
│     Product p = new Product("P1", "Book", 1500);                            │
│     double price = p.finalPrice(3);  // 4500.0                              │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ МЕТОД 3: public double finalPrice(int qty, PricePolicy policy)             │
├─────────────────────────────────────────────────────────────────────────────┤
│ Параметры:                                                                  │
│   - int qty: количество товаров                                             │
│   - PricePolicy policy: политика ценообразования                            │
│                                                                              │
│ Возвращает: Цену за qty товаров С УЧЕТОМ политики                          │
│                                                                              │
│ Логика:                                                                     │
│   1. Если qty <= 0 → вернуть 0.0                                           │
│   2. Если policy == null → вернуть finalPrice(qty) без скидки              │
│   3. Если !policy.applicableTo(this) → вернуть finalPrice(qty)             │
│   4. Иначе → вернуть policy.apply(this, qty)                               │
│                                                                              │
│ Пример использования:                                                       │
│     Product p = new Product("P1", "Book", 1500);                            │
│     PricePolicy discount = new PercentageOff(10);                           │
│     double price = p.finalPrice(2, discount);  // 2700.0 (10% скидка)      │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ МЕТОД 4: public double finalPrice(int qty, List<PricePolicy> policies)     │
├─────────────────────────────────────────────────────────────────────────────┤
│ Параметры:                                                                  │
│   - int qty: количество товаров                                             │
│   - List<PricePolicy> policies: список политик                              │
│                                                                              │
│ Возвращает: МИНИМАЛЬНУЮ цену среди всех политик                            │
│                                                                              │
│ Логика:                                                                     │
│   1. Если qty <= 0 → вернуть 0.0                                           │
│   2. Если список пустой → вернуть finalPrice(qty) без скидки               │
│   3. Перебрать все политики, вычислить цену для каждой                     │
│   4. Вернуть минимальную цену (лучшая для покупателя)                      │
│                                                                              │
│ Алгоритм выбора лучшей политики:                                           │
│     double best = Double.POSITIVE_INFINITY;                                 │
│     for (var pp : policies) {                                               │
│         double v = finalPrice(qty, pp);                                     │
│         if (v < best) best = v;                                             │
│     }                                                                        │
│     return best;                                                            │
│                                                                              │
│ Пример использования:                                                       │
│     Product p = new Product("P1", "Book", 1500);                            │
│     List<PricePolicy> rules = List.of(                                      │
│         new PercentageOff(10),  // -10% = 2700 KZT                          │
│         new FixedOff(50),       // -50 за шт = 2900 KZT                     │
│         new BogoHalf()          // 1+0.5 = 2250 KZT ← ЛУЧШАЯ               │
│     );                                                                       │
│     double bestPrice = p.finalPrice(2, rules);  // 2250.0                   │
└─────────────────────────────────────────────────────────────────────────────┘

ДЕМОНСТРАЦИЯ ПОЛИМОРФИЗМА:
    ✓ Method Overloading (перегрузка методов) - COMPILE-TIME POLYMORPHISM
      Компилятор выбирает метод по сигнатуре (количеству и типам параметров)

    ✓ Работа с интерфейсом PricePolicy - RUNTIME POLYMORPHISM
      В методе может быть передан любой объект, реализующий PricePolicy


================================================================================
  7. ИЗМЕНЕНИЯ В КЛАССЕ PhysicalProduct
================================================================================

Файл: src/product/PhysicalProduct.java
Место изменений: После метода getHeightCm(), строка ~76

ДОБАВЛЕНО: 2 переопределенных метода (Method Overriding)

┌─────────────────────────────────────────────────────────────────────────────┐
│ @Override                                                                   │
│ public double finalPrice(int qty, PricePolicy policy)                       │
├─────────────────────────────────────────────────────────────────────────────┤
│ ЦЕЛЬ: Добавить стоимость доставки ПОСЛЕ применения ценовой политики        │
│                                                                              │
│ Алгоритм:                                                                   │
│   1. Вызвать super.finalPrice(qty, policy) - получить цену со скидкой      │
│   2. Добавить estimateShippingCost() - стоимость доставки                  │
│   3. Вернуть итоговую сумму                                                │
│                                                                              │
│ Код:                                                                        │
│     double base = super.finalPrice(qty, policy);  // цена + скидка         │
│     return base + estimateShippingCost();         // + доставка            │
│                                                                              │
│ Пример:                                                                     │
│     PhysicalProduct laptop = new PhysicalProduct("P1", "Laptop", 450000, 1.8);│
│     laptop.trySetDimensions(35, 24, 2);                                     │
│     PricePolicy discount = new PercentageOff(10);                           │
│                                                                              │
│     Базовая цена: 450,000 KZT                                               │
│     Скидка 10%:   405,000 KZT                                               │
│     Доставка:         180 KZT (зависит от размеров/веса)                   │
│     ИТОГО:        405,180 KZT                                               │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ @Override                                                                   │
│ public double finalPrice(int qty, List<PricePolicy> policies)               │
├─────────────────────────────────────────────────────────────────────────────┤
│ ЦЕЛЬ: Выбрать лучшую политику, затем добавить доставку                     │
│                                                                              │
│ Алгоритм:                                                                   │
│   1. Вызвать super.finalPrice(qty, policies) - найти минимальную цену      │
│   2. Добавить estimateShippingCost() - стоимость доставки                  │
│   3. Вернуть итоговую сумму                                                │
│                                                                              │
│ Код:                                                                        │
│     double base = super.finalPrice(qty, policies);  // лучшая цена         │
│     return base + estimateShippingCost();           // + доставка          │
│                                                                              │
│ ВАЖНО:                                                                      │
│   Доставка добавляется ОДИН РАЗ на весь заказ, не на каждый товар!        │
└─────────────────────────────────────────────────────────────────────────────┘

ДЕМОНСТРАЦИЯ ПОЛИМОРФИЗМА:
    ✓ Method Overriding (переопределение методов) - RUNTIME POLYMORPHISM
      При вызове метода через ссылку Product, JVM вызовет версию из PhysicalProduct

    ✓ Специфичное поведение для подкласса
      Физические товары всегда добавляют стоимость доставки к финальной цене


================================================================================
  8. ИЗМЕНЕНИЯ В КЛАССЕ DigitalProduct
================================================================================

Файл: src/product/DigitalProduct.java
Место изменений: После метода getLicenseKey(), строка ~58

ДОБАВЛЕНО: 1 переопределенный метод (Method Overriding)

┌─────────────────────────────────────────────────────────────────────────────┐
│ @Override                                                                   │
│ public double finalPrice(int qty, PricePolicy policy)                       │
├─────────────────────────────────────────────────────────────────────────────┤
│ ЦЕЛЬ: Игнорировать политику BOGO-HALF для цифровых товаров                 │
│                                                                              │
│ Алгоритм:                                                                   │
│   1. Проверить, является ли policy экземпляром BogoHalf                    │
│   2. Если ДА → игнорировать политику, вернуть базовую цену                 │
│   3. Если НЕТ → применить политику через super.finalPrice(qty, policy)     │
│                                                                              │
│ Код:                                                                        │
│     if (policy instanceof product.pricing.BogoHalf) {                       │
│         return super.finalPrice(qty);  // БЕЗ скидки                        │
│     }                                                                        │
│     return super.finalPrice(qty, policy);  // С политикой                   │
│                                                                              │
│ Пример:                                                                     │
│     DigitalProduct ebook = new DigitalProduct("P2", "E-Book", 1500, 12.5);  │
│                                                                              │
│     // С политикой PercentageOff (работает)                                │
│     PricePolicy discount = new PercentageOff(10);                           │
│     double price1 = ebook.finalPrice(2, discount);  // 2700 KZT            │
│                                                                              │
│     // С политикой BogoHalf (игнорируется)                                 │
│     PricePolicy bogo = new BogoHalf();                                      │
│     double price2 = ebook.finalPrice(2, bogo);  // 3000 KZT (без скидки!)  │
│                                                                              │
│ ОБОСНОВАНИЕ:                                                                │
│   Акция "купи одну - вторую за полцены" применима только к физическим      │
│   товарам. Цифровые товары не имеют себестоимости копирования, поэтому     │
│   такая акция для них не имеет смысла.                                      │
└─────────────────────────────────────────────────────────────────────────────┘

ДЕМОНСТРАЦИЯ ПОЛИМОРФИЗМА:
    ✓ Method Overriding - RUNTIME POLYMORPHISM
      Цифровые товары имеют специфичное поведение для определенной политики

    ✓ Использование instanceof для проверки типа
      Позволяет реализовать type-specific behavior в рамках полиморфизма


================================================================================
  9. НОВЫЙ КЛАСС ShopDemo5
================================================================================

Файл: src/product/ShopDemo5.java

НАЗНАЧЕНИЕ:
    Демонстрация всех концепций полиморфизма в действии

ЧТО ДЕМОНСТРИРУЕТСЯ:

    1. ИНТЕРФЕЙСНЫЙ ПОЛИМОРФИЗМ (Interface-based Polymorphism)
       ┌──────────────────────────────────────────────────────────────┐
       │ List<PricePolicy> rules = List.of(                          │
       │     new PercentageOff(10),     // разные реализации          │
       │     new FixedOff(50),          // одного интерфейса          │
       │     new BogoHalf()                                           │
       │ );                                                           │
       └──────────────────────────────────────────────────────────────┘

    2. ПЕРЕГРУЗКА МЕТОДОВ (Method Overloading - Compile-Time Polymorphism)
       ┌──────────────────────────────────────────────────────────────┐
       │ p.finalPrice()              // без параметров                │
       │ p.finalPrice(qty)           // с количеством                 │
       │ p.finalPrice(qty, policy)   // с политикой                   │
       │ p.finalPrice(qty, rules)    // со списком политик            │
       └──────────────────────────────────────────────────────────────┘

    3. ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДОВ (Method Overriding - Runtime Polymorphism)
       ┌──────────────────────────────────────────────────────────────┐
       │ Product p = new PhysicalProduct(...);                        │
       │ // Вызовется версия из PhysicalProduct (добавится доставка)  │
       │ double price = p.finalPrice(2, discount);                    │
       │                                                               │
       │ Product p2 = new DigitalProduct(...);                        │
       │ // Вызовется версия из DigitalProduct (игнорируется BOGO)    │
       │ double price2 = p2.finalPrice(2, bogo);                      │
       └──────────────────────────────────────────────────────────────┘

    4. ПОЛИМОРФНЫЕ КОЛЛЕКЦИИ (Polymorphic Collections)
       ┌──────────────────────────────────────────────────────────────┐
       │ List<Product> items = List.of(laptop, ebook);               │
       │ // Единый интерфейс для разных типов товаров                │
       │                                                               │
       │ for (Product p : items) {                                    │
       │     // Полиморфный вызов - разное поведение                 │
       │     double price = p.finalPrice(qty, policy);               │
       │ }                                                            │
       └──────────────────────────────────────────────────────────────┘

СТРУКТУРА ВЫВОДА:
    ┌─────────────────────────────────────────────────────────────────┐
    │ Для каждого товара (Laptop, E-Book)                            │
    │   Для каждого количества (1, 2)                                │
    │     Показать:                                                   │
    │       - Базовую цену (без скидок)                              │
    │       - Цену с каждой политикой                                │
    │       - Лучшую цену (минимум из всех политик)                  │
    └─────────────────────────────────────────────────────────────────┘

КЛЮЧЕВЫЕ НАБЛЮДЕНИЯ ИЗ ВЫВОДА:
    ✓ Laptop (PhysicalProduct):
      - К каждой цене добавляется ~180 KZT (стоимость доставки)
      - BOGO-HALF применяется (для qty=2 выгоднее всего)

    ✓ E-Book (DigitalProduct):
      - Нет стоимости доставки
      - BOGO-HALF игнорируется (цена = базовая, без скидки)
      - Процентная скидка работает лучше всего


================================================================================
  10. РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ
================================================================================

КОМАНДЫ:
    javac -d out src/category/*.java src/product/*.java src/product/pricing/*.java
    java -cp out product.ShopDemo5

РЕЗУЛЬТАТЫ РАБОТЫ:

┌───────────────────────────────────────────────────────────────────────────┐
│ == Laptop | qty=1                                                         │
│    Base price: 450000,00 KZT                                              │
│    Percent-10.0%: 405180,00 KZT  ← 10% скидка + доставка 180             │
│    Fixed-50.0:    450130,00 KZT  ← -50 KZT + доставка 180 (хуже)         │
│    BOGO-HALF:     450180,00 KZT  ← не работает для 1 шт + доставка       │
│    Best(of all):  405180,00 KZT  ← лучшая = Percent-10%                   │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│ == Laptop | qty=2                                                         │
│    Base price: 900000,00 KZT                                              │
│    Percent-10.0%: 810180,00 KZT  ← 10% скидка + доставка                 │
│    Fixed-50.0:    900080,00 KZT  ← -100 KZT + доставка (хуже)            │
│    BOGO-HALF:     675180,00 KZT  ← 1 полная + 1 за 50% + доставка ✓      │
│    Best(of all):  675180,00 KZT  ← лучшая = BOGO-HALF (экономия 225K!)   │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│ == E-Book | qty=1                                                         │
│    Base price: 1500,00 KZT                                                │
│    Percent-10.0%: 1350,00 KZT  ← 10% скидка ✓                             │
│    Fixed-50.0:    1450,00 KZT  ← -50 KZT (хуже)                           │
│    BOGO-HALF:     1500,00 KZT  ← ИГНОРИРУЕТСЯ (= базовая цена)           │
│    Best(of all):  1350,00 KZT  ← лучшая = Percent-10%                     │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│ == E-Book | qty=2                                                         │
│    Base price: 3000,00 KZT                                                │
│    Percent-10.0%: 2700,00 KZT  ← 10% скидка ✓                             │
│    Fixed-50.0:    2900,00 KZT  ← -100 KZT (хуже)                          │
│    BOGO-HALF:     3000,00 KZT  ← ИГНОРИРУЕТСЯ (= базовая цена)           │
│    Best(of all):  2700,00 KZT  ← лучшая = Percent-10%                     │
└───────────────────────────────────────────────────────────────────────────┘

ПОДТВЕРЖДЕНИЕ РАБОТЫ ПОЛИМОРФИЗМА:
    ✓ PhysicalProduct добавляет доставку (~180 KZT) ко всем ценам
    ✓ DigitalProduct игнорирует BOGO-HALF (цена остается базовой)
    ✓ Метод finalPrice(qty, List) корректно выбирает минимальную цену
    ✓ Разные политики дают разные результаты для одного товара


================================================================================
  11. КОНЦЕПЦИИ ПОЛИМОРФИЗМА В ПРОЕКТЕ
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. COMPILE-TIME POLYMORPHISM (Полиморфизм времени компиляции)              │
├─────────────────────────────────────────────────────────────────────────────┤
│ Механизм: Method Overloading (Перегрузка методов)                          │
│                                                                              │
│ Где реализовано:                                                            │
│   • Product.finalPrice()         - 0 параметров                            │
│   • Product.finalPrice(qty)      - 1 параметр int                          │
│   • Product.finalPrice(qty, policy) - 2 параметра                          │
│   • Product.finalPrice(qty, policies) - 2 параметра (другой тип!)         │
│                                                                              │
│ Как работает:                                                               │
│   Компилятор выбирает нужный метод на основе СИГНАТУРЫ:                    │
│   - Количество параметров                                                   │
│   - Типы параметров                                                         │
│   Решение принимается во время компиляции, НЕ во время выполнения          │
│                                                                              │
│ Пример:                                                                     │
│   Product p = new Product("P1", "Book", 1500);                              │
│   p.finalPrice();          // компилятор → метод #1                        │
│   p.finalPrice(2);         // компилятор → метод #2                        │
│   p.finalPrice(2, policy); // компилятор → метод #3 или #4 (зависит от типа)│
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. RUNTIME POLYMORPHISM (Полиморфизм времени выполнения)                   │
├─────────────────────────────────────────────────────────────────────────────┤
│ Механизм: Method Overriding (Переопределение методов)                      │
│                                                                              │
│ Где реализовано:                                                            │
│   • PhysicalProduct.finalPrice(qty, policy)    - добавляет доставку        │
│   • PhysicalProduct.finalPrice(qty, policies)  - добавляет доставку        │
│   • DigitalProduct.finalPrice(qty, policy)     - игнорирует BogoHalf       │
│                                                                              │
│ Как работает:                                                               │
│   JVM выбирает метод на основе ФАКТИЧЕСКОГО ТИПА объекта (не типа ссылки): │
│                                                                              │
│   Product p1 = new PhysicalProduct(...);  // тип ссылки: Product           │
│   Product p2 = new DigitalProduct(...);   // фактический тип: разный!      │
│                                                                              │
│   p1.finalPrice(2, policy);  // JVM вызовет PhysicalProduct.finalPrice     │
│   p2.finalPrice(2, policy);  // JVM вызовет DigitalProduct.finalPrice      │
│                                                                              │
│ Ключевое отличие от Overloading:                                           │
│   Решение принимается во время ВЫПОЛНЕНИЯ, на основе реального объекта     │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. INTERFACE-BASED POLYMORPHISM (Полиморфизм через интерфейсы)             │
├─────────────────────────────────────────────────────────────────────────────┤
│ Механизм: Единый интерфейс, разные реализации (Strategy Pattern)           │
│                                                                              │
│ Где реализовано:                                                            │
│   Интерфейс: PricePolicy                                                    │
│   Реализации:                                                               │
│     • PercentageOff  - процентная скидка                                   │
│     • FixedOff       - фиксированная скидка                                │
│     • BogoHalf       - купи одну, вторую за полцены                        │
│                                                                              │
│ Как работает:                                                               │
│   Код работает с интерфейсом PricePolicy, не зная конкретной реализации:   │
│                                                                              │
│   public double finalPrice(int qty, PricePolicy policy) {                   │
│       // policy может быть ЛЮБЫМ классом, реализующим PricePolicy          │
│       return policy.apply(this, qty);  // полиморфный вызов                │
│   }                                                                          │
│                                                                              │
│ Преимущества:                                                               │
│   • Легко добавлять новые политики без изменения Product                   │
│   • Код Product не зависит от конкретных реализаций                        │
│   • Соблюдается принцип Open/Closed (SOLID)                                │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. SUBTYPE POLYMORPHISM (Полиморфизм подтипов)                             │
├─────────────────────────────────────────────────────────────────────────────┤
│ Механизм: Наследование, работа с базовым классом                            │
│                                                                              │
│ Где реализовано:                                                            │
│   Базовый класс: Product                                                    │
│   Подклассы:                                                                │
│     • PhysicalProduct  - физические товары (с доставкой)                   │
│     • DigitalProduct   - цифровые товары (без доставки, без BOGO)          │
│                                                                              │
│ Как работает:                                                               │
│   Код работает с типом Product, но получает поведение подкласса:           │
│                                                                              │
│   List<Product> items = List.of(                                            │
│       new PhysicalProduct(...),  // тип: Product, поведение: Physical      │
│       new DigitalProduct(...)    // тип: Product, поведение: Digital       │
│   );                                                                         │
│                                                                              │
│   for (Product p : items) {                                                 │
│       p.finalPrice(2, policy);  // разное поведение для каждого!           │
│   }                                                                          │
│                                                                              │
│ Принцип Liskov Substitution (SOLID):                                        │
│   Подклассы могут быть использованы везде, где ожидается базовый класс     │
└─────────────────────────────────────────────────────────────────────────────┘


================================================================================
  12. АРХИТЕКТУРНЫЕ ПРЕИМУЩЕСТВА
================================================================================

СРАВНЕНИЕ СТАРОГО И НОВОГО ПОДХОДА:

    ┌───────────────────────────────────────────────────────────────────┐
    │ СТАРЫЙ ПОДХОД (до Requirement 6)                                  │
    ├───────────────────────────────────────────────────────────────────┤
    │ • applyDiscount(double percent) - МУТИРУЕТ товар                  │
    │ • Скидка применяется один раз, меняет состояние                   │
    │ • Невозможно сравнить разные варианты скидок                      │
    │ • Нельзя отменить скидку после применения                         │
    │ • Только один тип скидки (процентная)                             │
    └───────────────────────────────────────────────────────────────────┘

    ┌───────────────────────────────────────────────────────────────────┐
    │ НОВЫЙ ПОДХОД (Requirement 6)                                      │
    ├───────────────────────────────────────────────────────────────────┤
    │ ✓ finalPrice(...) - НЕ мутирует товар (immutable)                │
    │ ✓ Можно вычислить цену с разными политиками без изменений        │
    │ ✓ Можно сравнить все политики и выбрать лучшую                   │
    │ ✓ Легко добавлять новые типы политик                             │
    │ ✓ Политики могут иметь сложную логику (BOGO, сезонные и т.д.)    │
    │ ✓ Разные товары могут по-разному реагировать на политики         │
    └───────────────────────────────────────────────────────────────────┘

РАСШИРЯЕМОСТЬ:

    Чтобы добавить новую политику, нужно:
    1. Создать новый класс, реализующий PricePolicy
    2. Реализовать методы name() и apply()
    3. Всё! Не нужно менять Product, PhysicalProduct, DigitalProduct

    Пример новой политики:
    ┌───────────────────────────────────────────────────────────────────┐
    │ public class SeasonalDiscount implements PricePolicy {           │
    │     public String name() { return "Seasonal-20%"; }              │
    │     public double apply(Product p, int qty) {                    │
    │         LocalDate now = LocalDate.now();                         │
    │         boolean isWinter = now.getMonth() == Month.DECEMBER;     │
    │         double discount = isWinter ? 0.8 : 1.0;                  │
    │         return p.getPrice() * qty * discount;                    │
    │     }                                                             │
    │ }                                                                 │
    └───────────────────────────────────────────────────────────────────┘

ТЕСТИРУЕМОСТЬ:

    ✓ Каждая политика - отдельный класс, легко тестировать изолированно
    ✓ Можно создать mock-политики для тестирования Product
    ✓ Метод apply() - pure function (не имеет побочных эффектов)


================================================================================
  13. ИТОГОВЫЙ ЧЕКЛИСТ ИЗМЕНЕНИЙ
================================================================================

Структура проекта:
    ✓ Создана папка src/product/pricing/
    ✓ Создан интерфейс PricePolicy.java
    ✓ Создан класс PercentageOff.java
    ✓ Создан класс FixedOff.java
    ✓ Создан класс BogoHalf.java
    ✓ Создан демо-класс ShopDemo5.java

Изменения в Product.java:
    ✓ Добавлен метод finalPrice() - 0 параметров
    ✓ Добавлен метод finalPrice(int qty) - 1 параметр
    ✓ Добавлен метод finalPrice(int qty, PricePolicy policy) - 2 параметра
    ✓ Добавлен метод finalPrice(int qty, List<PricePolicy>) - 2 параметра

Изменения в PhysicalProduct.java:
    ✓ Переопределен finalPrice(int qty, PricePolicy policy)
    ✓ Переопределен finalPrice(int qty, List<PricePolicy> policies)
    ✓ Оба метода добавляют стоимость доставки

Изменения в DigitalProduct.java:
    ✓ Переопределен finalPrice(int qty, PricePolicy policy)
    ✓ Игнорирует политику BogoHalf

Тестирование:
    ✓ Код успешно компилируется
    ✓ ShopDemo5 работает корректно
    ✓ PhysicalProduct добавляет доставку
    ✓ DigitalProduct игнорирует BOGO-HALF
    ✓ Выбор лучшей политики работает правильно


================================================================================
  14. КОНЦЕПТУАЛЬНАЯ СХЕМА ВЗАИМОДЕЙСТВИЯ
================================================================================

                            ┌──────────────┐
                            │<<interface>> │
                            │ PricePolicy  │
                            └──────┬───────┘
                                   │
                   ┌───────────────┼───────────────┐
                   │               │               │
              ┌────▼─────┐   ┌────▼─────┐   ┌────▼─────┐
              │Percentage│   │ FixedOff │   │BogoHalf  │
              │   Off    │   │          │   │          │
              └──────────┘   └──────────┘   └──────────┘
                   ▲               ▲               ▲
                   │               │               │
                   └───────────────┼───────────────┘
                                   │
                            ┌──────▼──────┐
                            │   Product   │
                            │ finalPrice()│
                            └──────┬──────┘
                                   │
                   ┌───────────────┴───────────────┐
                   │                               │
            ┌──────▼──────┐                 ┌─────▼──────┐
            │  Physical   │                 │  Digital   │
            │   Product   │                 │  Product   │
            │ +shipping   │                 │ -BogoHalf  │
            └─────────────┘                 └────────────┘

Поток вызова:
    1. ShopDemo5 создает List<Product> и List<PricePolicy>
    2. Вызывает p.finalPrice(qty, policy) для каждого товара
    3. Product делегирует расчет политике: policy.apply(this, qty)
    4. Подклассы (Physical/Digital) переопределяют поведение
    5. Возвращается финальная цена с учетом всех правил


================================================================================
  КОНЕЦ ДОКУМЕНТАЦИИ
================================================================================

Автор: Claude Code Assistant
Дата: 2025-11-07
Requirement: Practice 5 — Polymorphism: Price Policies + Method Overloading/Overriding

Все требования Requirement 6 успешно реализованы и протестированы!
